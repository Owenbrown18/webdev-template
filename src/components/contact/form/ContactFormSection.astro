---
import {
  contact,
  getContactFormBackgroundTone,
  isContactFormAnimationEnabled,
} from '../../../config/content';
import {
  normalizeBackgroundTone,
  normalizeBackgroundColor,
  sectionBackgroundClass,
  sectionBackgroundToneAttr,
  createBackgroundStyle,
} from '../../../utils/background';
import ContactForm from '../info-form/ContactForm.astro';

const settings = contact.contactForm ?? {};
const props = (Astro.props ?? {}) as Record<string, any>;
const {
  backgroundTone: overrideTone,
  backgroundColor: overrideColor,
  backgroundClass: overrideClass,
  animation: animationOverride,
  eyebrow: eyebrowOverride,
  title: titleOverride,
  intro: introOverride,
  ...restProps
} = props;

const eyebrow = (eyebrowOverride ?? settings.eyebrow ?? undefined) as string | undefined;
const title = (titleOverride ?? settings.title ?? undefined) as string | undefined;
const intro = (introOverride ?? settings.intro ?? undefined) as string | undefined;
const fallbackTone = getContactFormBackgroundTone();
const backgroundTone = normalizeBackgroundTone(
  overrideTone ?? settings.background?.tone ?? fallbackTone,
);
const backgroundClass = overrideClass ?? sectionBackgroundClass(backgroundTone);
const backgroundToneAttr = sectionBackgroundToneAttr(backgroundTone);
const backgroundColor = normalizeBackgroundColor(overrideColor ?? settings.background?.color);
const backgroundStyle = createBackgroundStyle(backgroundColor, backgroundTone);
const animationSetting =
  animationOverride !== undefined ? animationOverride : settings.animation;
const shouldAnimate = animationSetting ?? isContactFormAnimationEnabled();
const sectionClasses = ['section-shell', backgroundClass].filter(Boolean).join(' ');
const containerClasses = [
  'section-container max-w-5xl space-y-8',
  shouldAnimate
    ? 'motion-safe:opacity-0 motion-safe:translate-y-6 motion-safe:transition-all motion-safe:duration-[900ms] motion-safe:ease-out data-[visible=true]:motion-safe:opacity-100 data-[visible=true]:motion-safe:translate-y-0'
    : '',
].filter(Boolean).join(' ');
const formClasses = [
  'mt-0 w-full',
  shouldAnimate
    ? 'motion-safe:opacity-0 motion-safe:translate-y-6 motion-safe:transition-all motion-safe:duration-[900ms] motion-safe:ease-out data-[visible=true]:motion-safe:opacity-100 data-[visible=true]:motion-safe:translate-y-0'
    : '',
].filter(Boolean).join(' ');
---
<section
  class={sectionClasses}
  data-background-tone={backgroundToneAttr ?? undefined}
  style={backgroundStyle}
  data-contact-form-root={shouldAnimate ? 'true' : undefined}
  {...restProps}
>
  <div class={containerClasses} data-contact-form-container>
    {(eyebrow || title || intro) && (
      <div class="section-intro mx-auto max-w-3xl text-center">
        {eyebrow && <p class="section-eyebrow">{eyebrow}</p>}
        {title && <h2 class="section-heading">{title}</h2>}
        {intro && <p class="section-subtitle">{intro}</p>}
      </div>
    )}
    <ContactForm
      id="contact-form"
      class={formClasses}
      data-contact-form-card
    />
  </div>
  {shouldAnimate ? (
    <script>
      const roots = Array.from(document.querySelectorAll('[data-contact-form-root="true"]'));
      const supportMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';
      const prefersReducedMotion = supportMatchMedia
        ? window.matchMedia('(prefers-reduced-motion: reduce)').matches
        : false;
      const reveal = (el) => {
        if (el instanceof HTMLElement) {
          el.dataset.visible = 'true';
        }
      };

      roots.forEach((root) => {
        if (!(root instanceof HTMLElement)) return;
        if (root.dataset.contactFormAnimated === 'true') return;

        root.dataset.contactFormAnimated = 'true';
        const container = root.querySelector('[data-contact-form-container]');
        const card = root.querySelector('[data-contact-form-card]');

        if (prefersReducedMotion || !('IntersectionObserver' in window)) {
          reveal(container);
          reveal(card);
          return;
        }

        const targets = [container, card].filter((node) => node instanceof HTMLElement);
        const observer = new IntersectionObserver(
          (entries, obs) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                reveal(entry.target);
                obs.unobserve(entry.target);
              }
            });
          },
          {
            rootMargin: '0px 0px -10% 0px',
            threshold: 0.1,
          },
        );

        targets.forEach((target) => observer.observe(target));
      });
    </script>
  ) : null}
</section>
